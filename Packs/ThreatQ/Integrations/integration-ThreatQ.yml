beta: true
category: Data Enrichment & Threat Intelligence
commonfields:
  id: ThreatQ_Beta
  version: -1
configuration:
- defaultvalue: ''
  display: TQ API URL E.g. https://192.168.1.136/api
  name: apiUrl
  required: true
  type: 0
- defaultvalue: ''
  display: TQ Client ID
  name: client_id
  required: true
  type: 0
- defaultvalue: ''
  display: Email
  name: credentials
  required: true
  type: 9
- defaultvalue: 'false'
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: 'false'
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: ThreatQ Integration
detaileddescription: "You must have a ThreatQ user account to retrieve an api token.\
  \ The api token is required for all api requests. \nThreatQ provides indicator scoring\
  \ weighting for indicators and their contextual information, such as sources, attributes,\
  \ and indicator types, as they are added to ThreatQ.\nFor detailed information on\
  \ ThreatQ scoring please refer to https://helpcenter.threatq.com/\n\nNote: This\
  \ is a beta Integration, which lets you implement and test pre-release software.\
  \ Since the integration is beta, it might contain bugs. Updates to the integration\
  \ during the beta phase might include non-backward compatible features. We appreciate\
  \ your feedback on the quality and usability of the integration to help us identify\
  \ issues, fix them, and continually improve."
display: ThreatQ_Beta
fromversion: 4.1.0
image: data:image/png;base64,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
name: ThreatQ_Beta
script:
  commands:
  - arguments:
    - default: true
      defaultValue: Naid
      description: keyword
      name: keyword
      required: true
    description: Search ThreatQ repository by keywords
    name: tq-search-by-name
    outputs:
    - contextPath: ThreatQ.description
      description: Description
  - arguments:
    - default: true
      defaultValue: 8.8.8.8
      description: IP address
      isArray: true
      name: ip
      required: true
    description: 'Run ip check against ThreatQ '
    name: ip
    outputs:
    - contextPath: ThreatQ.score
      description: ThreatQ score
    - contextPath: ThreatQ.name
      description: ThreatQ name
    - contextPath: DBotScore.Vendor
      description: DBotScore Vendor
    - contextPath: DBotScore.Malicious
      description: DBotScore Malicious status
  - arguments:
    - default: true
      defaultValue: www.google.com
      description: URL or FQDN
      isArray: true
      name: url
      required: true
    description: Run url check against ThreatQ
    name: url
    outputs:
    - contextPath: ThreatQ.score
      description: ThreatQ score
    - contextPath: ThreatQ.name
      description: ThreatQ name
    - contextPath: DBotScore.Vendor
      description: DBotScore Vendor
    - contextPath: DBotScore.Malicious
      description: DBotScore Malicious status
  - arguments:
    - default: true
      defaultValue: google.exe
      description: File name, MD5 or SHA
      isArray: true
      name: file
      required: true
    description: Run file check against ThreatQ
    name: file
    outputs:
    - contextPath: ThreatQ.score
      description: ThreatQ score
    - contextPath: ThreatQ.name
      description: ThreatQ name
    - contextPath: DBotScore.Vendor
      description: DBotScore Vendor
    - contextPath: DBotScore.Malicious
      description: DBotScore Malicious status
  runonce: false
  script: "''' IMPORTS '''\nimport os\nimport datetime\nimport requests\nimport json\n\
    \n# disable insecure warnings\nrequests.packages.urllib3.disable_warnings()\n\n\
    ''' GLOBAL VARS '''\n\nAPI_URL = demisto.params()['apiUrl']\nAPI_TOKEN_URL = API_URL\
    \ + \"/token\"\nCLIENT_ID = demisto.params()['client_id']\nEMAIL = demisto.getParam('credentials').get('identifier')\n\
    PASSWORD = demisto.getParam('credentials').get('password')\nUSE_SSL = not demisto.params().get('insecure',\
    \ False)\n\n\n''' HELPER FUNCTIONS '''\n\ndef load_proxy():\n    # Load the system\
    \ configured proxy if enabled in configuration\n    proxy = {}\n    if 'proxy'\
    \ in demisto.params():\n        proxy[\"http\"] = os.environ[\"http_proxy\"]\n\
    \        proxy[\"https\"] = os.environ[\"https_proxy\"]\n    return proxy\n\n\
    PROXY = load_proxy()\n\ndef get_errors_string_from_bad_request(bad_request_results):\n\
    \    errors_list = bad_request_results.json().get(\"errors\", [])\n    errors_string\
    \ = \"\"\n    error_num = 1\n    if errors_list:\n        errors_string = \"Errors\
    \ from server: \\n\"\n        for error in errors_list:\n            errors_string\
    \ += \"Error #{0}: {1}\\n\".format(error_num, error)\n            error_num +=\
    \ 1\n    return errors_string\n\n# ThreatQ auth based on OAuth 2.0 credential\
    \ grand method\ndef tq_access():\n    data = {'grant_type': 'password','email':\
    \ EMAIL, 'password': PASSWORD, 'client_id': CLIENT_ID}\n    access_token_response\
    \ = requests.post(API_TOKEN_URL, data=data, verify=False, allow_redirects=False)\n\
    \n    tokens = json.loads(access_token_response.text)\n    if int(access_token_response.status_code)\
    \ >= 400:\n        errors_string = get_errors_string_from_bad_request(access_token_response)\n\
    \        error_message = \"Authentication failed, unable to retrieve an access\
    \ token.\\n {}\".format(errors_string)\n        return_error(error_message)\n\n\
    \    new_integration_context = {\n        \"access_token\": tokens['access_token'],\n\
    \        \"access_token_creation_time\": int(time.time()) -1, # decrementing one\
    \ second to be on the safe side\n        \"access_token_expires_in\": tokens['expires_in']\n\
    \    }\n    demisto.setIntegrationContext(new_integration_context)\n    token\
    \ = tokens['access_token']\n    return token\n\n\ndef access_token_not_expired():\n\
    \        epoch_time_now = time.time()\n        epoch_time_when_token_granted =\
    \ demisto.getIntegrationContext().get(\"access_token_creation_time\")\n      \
    \  token_time_until_expiration = demisto.getIntegrationContext().get(\"access_token_expires_in\"\
    )\n        return int(epoch_time_now) - int(epoch_time_when_token_granted) < int(token_time_until_expiration)\n\
    \n\ndef get_access_token():\n    existing_access_token = demisto.getIntegrationContext().get(\"\
    access_token\")\n    if existing_access_token and access_token_not_expired():\n\
    \        return existing_access_token\n    else:\n        new_access_token = tq_access()\n\
    \        return new_access_token\n\n\n# remove html tags from ThreatQ description\
    \ field\ndef cleanhtml(raw_html):\n  cleanr = re.compile('<.*?>')\n  cleantext\
    \ = re.sub(cleanr, '', raw_html)\n  return cleantext\n\n\n''' Catch-all function\
    \ for all command '''\ndef query_tq(keyword):\n    '''\n    This function handles\
    \ all the querying of threatq\n    '''\n    tq_url = API_URL + \"/search?query=\"\
    \ + keyword\n    access_token = get_access_token()\n    api_call_headers = {'Authorization':\
    \ 'Bearer ' + access_token}\n    api_call_response = requests.get(tq_url, headers=api_call_headers,\
    \ verify=False)\n\n    response = json.loads(api_call_response.text)\n\n    #\
    \ Find ThreatQ object type and object id based on keyword search results\n\n \
    \   try:\n        object_type = str(response['data'][0]['object'])\n        object_id\
    \ = str(response['data'][0]['id']) # get the object id from the query results\n\
    \    except Exception, e:\n        results = {'ContentsFormat': formats['markdown'],\
    \ 'Type': entryTypes['note'], 'Contents': \"No results from ThreatQ\"}\n     \
    \   return results\n    results = describe_by_id(object_type,object_id)\n    return\
    \ results\n\n\n''' FUNCTIONS '''\n\n''' Get ThreatQ object details '''\ndef describe_by_id(tq_obj_type,tq_obj_id):\n\
    \    md = ''\n\n    # build the ThreatQ query url\n    if tq_obj_type == \"indicator\"\
    :\n        tq_url = API_URL + \"/indicators\" + \"/\" + tq_obj_id\n    elif tq_obj_type\
    \ == \"adversary\":\n        tq_url = API_URL + \"/adversaries\" + \"/\" + tq_obj_id\n\
    \    elif tq_obj_type == \"event\":\n        tq_url = API_URL + \"/events\" +\
    \ \"/\" + tq_obj_id\n    else:\n        tq_url = API_URL + \"/\" + tq_obj_type\
    \ + \"/\" + tq_obj_id\n\n    # get ThreatQ response\n    access_token = get_access_token()\n\
    \    api_call_headers = {'Authorization': 'Bearer ' + access_token}\n    api_call_response\
    \ = requests.get(tq_url, headers=api_call_headers, verify=False)\n    response\
    \ = json.loads(api_call_response.text)\n\n    if not response or len(response['data'])\
    \ == 0:\n        return \"Found in ThreatQ, but no context\"\n\n    description\
    \ = response['data']['description']\n    name = response['data']['value']\n\n\
    \    tq_attributes = None\n    dbot_score = None\n\n    if tq_obj_type == \"indicator\"\
    :\n        result = tq_indicator(name)\n        tq_attributes = result['attributes']\n\
    \        dbot_score = result['dbotscore']\n\n\n    # Description in clear text\
    \ will be sent to War Room\n    if description:\n        clean_desc = cleanhtml(description)\n\
    \    else:\n        clean_desc = \"No description found in ThreatQ\"\n\n    last_update\
    \ = str(response['data']['updated_at'])\n\n    tq_desc = {\n        'name': name,\n\
    \        'last_update' : last_update,\n        'description' : clean_desc,\n \
    \       'is_indicator': str(tq_obj_type == \"indicator\")\n    }\n\n\n    md +=\
    \ \"## TQ Object: \" + tq_obj_type + \" ID: \" + tq_obj_id + \"\\n\"\n    # Build\
    \ a ThreatQ Response table\n    md += tableToMarkdown('ThreatQ Response',tq_desc)\n\
    \n    if tq_obj_type == \"indicator\":\n        if not tq_attributes or len(tq_attributes)\
    \ == 0:\n            md += \"Found no attributs\"\n        else:\n           \
    \ md += tableToMarkdown(\"Attributes\", tq_attributes)\n            tq_desc.update(tq_attributes)\n\
    \n    entry2 = {\n        'Type': entryTypes['note'],\n        'Contents': tq_desc,\n\
    \        'ContentsFormat': formats['json'],\n        'ReadableContentsFormat':\
    \ formats['markdown'],\n        'HumanReadable': md,\n        'EntryContext':\
    \ {'ThreatQ(val.name && val.name == obj.name)': createContext(tq_desc, removeNull=True)},\n\
    \        }\n\n    if dbot_score:\n        entry2['EntryContext']['DBotScore(val.Vendor\
    \ && val.Indicator && val.Vendor == obj.Vendor && val.Indicator == obj.Indicator)']\
    \ = createContext(dbot_score, removeNull=True)\n\n    return entry2\n\ndef create_dbot_score(ind_name,\
    \ ind_score):\n\n    return dbot_score\n''' Get ThreatQ indicator's score and\
    \ attributes '''\n\ndef tq_indicator(indicator):\n    '''\n    This function parse\
    \ all the attributes of an indicator\n    '''\n    tq_url = API_URL + \"/indicators/?value=\"\
    \ + indicator + \"&with=score,attributes,sources\"\n\n    # get ThreatQ response\
    \ on indicators attributes\n    access_token = get_access_token()\n    api_call_headers\
    \ = {'Authorization': 'Bearer ' + access_token}\n    api_call_response = requests.get(tq_url,\
    \ headers=api_call_headers, verify=False)\n    try:\n        response = json.loads(api_call_response.text)\n\
    \    except requests.exceptions.RequestException as e:\n        md += '## TQ cound\
    \ not FIND this indicator\\n'\n        exit(1)\n    # check if any attributes\n\
    \    attributes = response[\"data\"][0][\"attributes\"]\n    score = response[\"\
    data\"][0][\"score\"]\n    sources = response[\"data\"][0][\"sources\"][0]\n \
    \   gen_score = score[\"generated_score\"]\n    manual_score = score[\"manual_score\"\
    ]\n    source = sources[\"name\"]\n\n    if not manual_score:\n        manual_score\
    \ = 0\n\n    ind_score = max(float(gen_score),float(manual_score))\n\n    '''\
    \ TBD - ThreatQ score to dbot_score conversion '''\n    if ind_score >= 8 :\n\
    \        dbot_score = 3\n        malicious = {\n            'Vendor' : 'ThreatQ',\n\
    \            'Detections' : 'high risk',\n        }\n    elif 4 < ind_score <\
    \ 8:\n        dbot_score = 2\n        malicious = {\n            'Vendor' : 'ThreatQ',\n\
    \            'Detections' : 'mid risk',\n        }\n    elif ind_score <= 2:\n\
    \        dbot_score = 1\n        malicious = {\n            'Vendor' : 'ThreatQ',\n\
    \            'Detections' : 'low risk',\n        }\n\n    dbot_score = {\n   \
    \             'Vendor' : 'ThreatQ',\n                'Indicator' : indicator,\n\
    \                'Type' : 'ip',\n                'Score' : dbot_score,\n     \
    \           'Malicious' : malicious,\n            }\n\n\n    md = ''\n\n    try:\n\
    \        length = len(attributes)\n        if length > 0:\n            md += \"\
    ## TQ found \" + str(length) + \" attributes\\n\"\n        else:\n           \
    \ md += \"## TQ found no attributes\\n\"\n        tq_attr = {\n            'name'\
    \ : indicator,\n            'score' : ind_score\n        }\n\n        for x in\
    \ range(length):\n            name = str(attributes[x][\"name\"])\n          \
    \  value = str(attributes[x][\"value\"])\n            tq_attr[name] = value\n\
    \            md += \"Attribute \" + name + \" is \" + value + \"\\n\"\n      \
    \  tq_attr_context = dict(tq_attr)\n    except:\n        md += '## TQ could not\
    \ EXTRACT attributes\\n'\n        pass\n\n    entry3 = {\n        'Type': entryTypes['note'],\n\
    \        'Contents': tq_attr_context,\n        'ContentsFormat': formats['json'],\n\
    \        'ReadableContentsFormat': formats['markdown'],\n        'HumanReadable':\
    \ md,\n        'EntryContext': {'ThreatQ(val.name && val.name == obj.name)': createContext(tq_attr_context,\
    \ removeNull=True),\n                    'DBotScore(val.Vendor && val.Indicator\
    \ && val.Vendor == obj.Vendor && val.Indicator == obj.Indicator)' :\n        \
    \        createContext(dbot_score, removeNull=True),\n        }\n    }\n    #\
    \ demisto.results(entry3)\n    return {'attributes': tq_attr_context,\n      \
    \      'dbotscore': dbot_score }\n\n\n''' EXECUTION CODE '''\nLOG('command is\
    \ %s' % (demisto.command(), ))\ntry:\n    if demisto.command() == 'test-module':\n\
    \        token = tq_access()\n        if token:\n            demisto.results('ok')\n\
    \        else:\n            demisto.results('test failed')\n    elif demisto.command()\
    \ == 'tq-search-by-name':\n        args = demisto.args()\n        keyword = demisto.get(args,\
    \ 'keyword')\n        results = query_tq(keyword)\n        demisto.results(results)\n\
    \    elif demisto.command() == 'ip':\n        args = demisto.args()\n        ip\
    \ = demisto.get(args, 'ip')\n        results = query_tq(ip)\n        demisto.results(results)\n\
    \    elif demisto.command() == 'url':\n        args = demisto.args()\n       \
    \ url = demisto.get(args, 'url')\n        results = query_tq(url)\n        demisto.results(results)\n\
    \    elif demisto.command() == 'file':\n        args = demisto.args()\n      \
    \  file = demisto.get(args, 'file')\n        results = query_tq(file)\n      \
    \  demisto.results(results)\n\n    elif demisto.command() == 'fetch-incidents':\n\
    \        fetch_incidents()\n\nexcept Exception, e:\n    raise\n    return_error(e)\n\
    \n\n# Params are of the type given in the integration page creation."
  subtype: python2
  type: python
tests:
- No test
toversion: 4.1.9
